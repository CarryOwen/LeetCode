#include "iostream"
#include "string"
using namespace std;
//运算符重载
//关键字operator后面加上需要重载的运算符符号
/*
返回值类型 operator 运算符 （形参列表）
{
    //函数体
}
*/
///形参列表
/*
一般情况下，赋值运算符重载函数的参数是函数所在类的const类型的引用，加const的引用原因如下：
    1`程序员不希望在函数中对已经用const修饰的值做任何修改。
        加上const后，对于const和非const的参数，函数就能接受；如果不加，就只能接受非const的参数。
    2`加引用的原因:
        加上引用后可以有效的避免函数调用时对实参的拷贝，提高了程序的效率。
Notes：以上的规定不是强制性规定。可以不加const，也可以没有引用，甚至参数可以不是函数所在的对象。
*/
//返回值
/*
一般情况下，返回值是被赋值者的引用，即*this，原因如下：
    1`返回*this，避免了函数的一次拷贝，提高程序效率。
    2`返回引用还可以达到连续赋值的作用，比如"a = b = c"。
        如果返回类型不是引用而是返回值类型，那么在执行b = c 时候，调用赋值运算符重载函数，
        在函数返回的时候，会形成一个无名的临时对象，接着拷贝临时对象，然后将这个临时对象返回，
        但是这临时对象是一个右值，再进行a = 时候，会出错。
*/
//调用时机··当为一个类对象赋值时，会由该对象调用该类的赋值运算符重载函数。
/*   MyStr str1;
    str1 = str2;
    MyStr str3 = str2;

比如上述例子，定义个MyStr的类。第二个语句和第三个语句在调用函数上面是有区别的。
MyStr str1；是str1的声明加定义，调用无参数的构造函数，
所以str2 = str1时在str1已经存在的情况下用str2来为str1赋值，调用赋值运算符重载函数；
而MyStr str3 = str2；调用的是拷贝构造函数。
*/

int main()
{
    return 0;
}